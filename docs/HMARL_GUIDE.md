# ü§ñ HMARL System Guide

## Hierarchical Multi-Agent Reinforcement Learning para Trading

---

## üìä Vis√£o Geral do Sistema HMARL

O sistema HMARL (Hierarchical Multi-Agent Reinforcement Learning) implementa 4 agentes especializados que trabalham em conjunto para tomar decis√µes de trading mais robustas e adaptativas.

### Arquitetura Hier√°rquica

```
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   Consensus Engine   ‚îÇ
                    ‚îÇ    (Coordenador)     ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                               ‚îÇ
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ              ‚îÇ              ‚îÇ             ‚îÇ
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ  OrderFlow    ‚îÇ ‚îÇ Liquidity ‚îÇ ‚îÇTapeReading‚îÇ ‚îÇFootprint  ‚îÇ
       ‚îÇ  Specialist   ‚îÇ ‚îÇ   Agent   ‚îÇ ‚îÇ   Agent   ‚îÇ ‚îÇPattern    ‚îÇ
       ‚îÇ     (30%)     ‚îÇ ‚îÇ   (20%)   ‚îÇ ‚îÇ   (25%)   ‚îÇ ‚îÇ  (25%)    ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üéØ Agentes Especializados

### 1. OrderFlowSpecialist (30% peso)

**Objetivo:** Analisar o fluxo de ordens para identificar press√£o compradora/vendedora

**Features Monitoradas:**
- `order_flow_imbalance_5, _10, _20`
- `signed_volume_5, _10, _20`
- `trade_flow_5, _10`
- `book_imbalance`
- `book_pressure`

**Estrat√©gias de Detec√ß√£o:**
```python
class OrderFlowSpecialist:
    def analyze(self, features):
        # 1. Absor√ß√£o de Volume
        if features['signed_volume_10'] > threshold and \
           features['price_change'] < 0.001:
            # Volume sendo absorvido sem mover pre√ßo
            signal = "Absor√ß√£o detectada"
        
        # 2. Diverg√™ncia de Fluxo
        if features['order_flow_imbalance_5'] > 0.3 and \
           features['returns_5'] < 0:
            # Fluxo comprador mas pre√ßo caindo
            signal = "Diverg√™ncia bullish"
        
        # 3. Momentum de Fluxo
        if all(features[f'order_flow_imbalance_{p}'] > 0.2 
               for p in [5, 10, 20]):
            # Fluxo consistente em m√∫ltiplos per√≠odos
            signal = "Momentum forte"
```

**Sinais Gerados:**
- `STRONG_BUY`: Absor√ß√£o vendedora + diverg√™ncia bullish
- `BUY`: Momentum comprador consistente
- `HOLD`: Fluxo neutro ou inconclusivo
- `SELL`: Momentum vendedor consistente
- `STRONG_SELL`: Absor√ß√£o compradora + diverg√™ncia bearish

### 2. LiquidityAgent (20% peso)

**Objetivo:** Monitorar liquidez e profundidade do book para timing de entrada/sa√≠da

**Features Monitoradas:**
- `bid_volume_total, ask_volume_total`
- `bid_levels_active, ask_levels_active`
- `spread, spread_ma, spread_std`
- `book_depth_imbalance`
- `liquidity_consumption_rate`

**Estrat√©gias de Detec√ß√£o:**
```python
class LiquidityAgent:
    def analyze(self, features):
        # 1. Liquidez Seca
        if features['bid_volume_total'] < historical_avg * 0.5:
            # Pouca liquidez no bid - cuidado com vendas
            risk = "HIGH"
        
        # 2. Suporte/Resist√™ncia por Volume
        if features['bid_levels_active'] > 4 and \
           features['bid_volume_total'] > threshold:
            # Forte suporte no book
            signal = "Suporte robusto"
        
        # 3. Spread Analysis
        if features['spread'] > features['spread_ma'] * 1.5:
            # Spread alargando - poss√≠vel movimento
            signal = "Preparar para volatilidade"
```

**M√©tricas de Liquidez:**
- `liquidity_score`: 0-1 (qualidade da liquidez)
- `execution_risk`: LOW/MEDIUM/HIGH
- `optimal_size`: Tamanho recomendado baseado em liquidez

### 3. TapeReadingAgent (25% peso)

**Objetivo:** Ler a "fita" de neg√≥cios para identificar atividade institucional

**Features Monitoradas:**
- `trade_flow_5, _10`
- `volume_20, _50, _100`
- `buy_intensity, sell_intensity`
- `large_trade_ratio`
- `trade_velocity`

**Padr√µes Identificados:**
```python
class TapeReadingAgent:
    def analyze(self, features):
        # 1. Iceberg Orders
        if features['trade_count'] > normal and \
           features['avg_trade_size'] < normal:
            # Muitos trades pequenos - poss√≠vel iceberg
            pattern = "Iceberg detectado"
        
        # 2. Institutional Sweeps
        if features['large_trade_ratio'] > 0.3 and \
           features['trade_velocity'] > threshold:
            # Trades grandes e r√°pidos
            pattern = "Institutional buying"
        
        # 3. Stop Hunting
        sudden_volume = features['volume_5'] > features['volume_20'] * 3
        price_reversal = abs(features['returns_5']) > 0.01
        if sudden_volume and price_reversal:
            pattern = "Poss√≠vel stop hunt"
```

**Classifica√ß√£o de Trades:**
- `RETAIL`: Trades pequenos, aleat√≥rios
- `ALGORITHMIC`: Trades consistentes, mesmo tamanho
- `INSTITUTIONAL`: Trades grandes, direcionais
- `MARKET_MAKER`: Two-way flow, spread capture

### 4. FootprintPatternAgent (25% peso)

**Objetivo:** Analisar padr√µes de volume e pegadas deixadas por grandes players

**Features Monitoradas:**
- `volume_profile_skew`
- `volume_concentration`
- `delta_cumulative`
- `top_trader_ratio`
- `top_trader_side_bias`

**Padr√µes de Footprint:**
```python
class FootprintPatternAgent:
    def analyze(self, features):
        # 1. P-Pattern (Compra no fundo)
        if features['volume_concentration'] > 0.7 and \
           features['price_level'] == "low":
            pattern = "P-Pattern bullish"
        
        # 2. b-Pattern (Venda no topo)
        if features['volume_concentration'] > 0.7 and \
           features['price_level'] == "high":
            pattern = "b-Pattern bearish"
        
        # 3. Unfinished Auction
        if features['delta_cumulative'] > 0 and \
           features['close'] < features['vwap']:
            pattern = "Unfinished business - mais alta"
        
        # 4. Volume Clusters
        if features['volume_profile_skew'] > 0.3:
            # Volume concentrado em n√≠veis espec√≠ficos
            pattern = "N√≠veis importantes identificados"
```

**M√©tricas de Footprint:**
- `delta`: Diferen√ßa entre volume comprador/vendedor
- `cumulative_delta`: Delta acumulado da sess√£o
- `imbalance_zones`: Zonas de desequil√≠brio
- `poc` (Point of Control): Pre√ßo com maior volume

## üéÆ Sistema de Consenso

### Vota√ß√£o Ponderada Adaptativa

```python
class ConsensusEngine:
    def __init__(self):
        self.ml_weight = 0.40
        self.agent_weights = {
            'OrderFlowSpecialist': 0.30,
            'LiquidityAgent': 0.20,
            'TapeReadingAgent': 0.25,
            'FootprintPatternAgent': 0.25
        }
        
    def calculate_consensus(self, ml_pred, agent_signals):
        # 1. Coletar votos
        votes = {
            'ml': ml_pred * self.ml_weight,
            'agents': {}
        }
        
        for agent, signal in agent_signals.items():
            weight = self.agent_weights[agent]
            confidence = signal['confidence']
            direction = signal['direction']  # -1, 0, 1
            
            votes['agents'][agent] = direction * confidence * weight
        
        # 2. Calcular consenso
        ml_vote = votes['ml']
        agent_vote = sum(votes['agents'].values()) * 0.60
        
        final_signal = ml_vote + agent_vote
        
        # 3. Determinar a√ß√£o
        if final_signal > 0.3:
            return 'BUY'
        elif final_signal < -0.3:
            return 'SELL'
        else:
            return 'HOLD'
```

### Ajuste Adaptativo de Pesos

```python
def update_weights(self, performance_history):
    """Ajusta pesos baseado em performance"""
    
    for agent in self.agent_weights:
        # Calcular accuracy do agente
        accuracy = performance_history[agent]['accuracy']
        sharpe = performance_history[agent]['sharpe']
        
        # Ajustar peso proporcionalmente
        performance_score = accuracy * 0.6 + sharpe * 0.4
        
        if performance_score > 0.7:
            self.agent_weights[agent] *= 1.1  # Aumenta 10%
        elif performance_score < 0.4:
            self.agent_weights[agent] *= 0.9  # Reduz 10%
    
    # Normalizar pesos
    total = sum(self.agent_weights.values())
    for agent in self.agent_weights:
        self.agent_weights[agent] /= total
```

## üìà Estrat√©gias de Trading por Consenso

### Estrat√©gia 1: Consenso Forte (High Confidence)

```python
if all(agent_signals[agent]['direction'] == 1 for agent in agents):
    # Todos os agentes concordam em comprar
    signal = 'STRONG_BUY'
    size = max_position_size
    confidence = 0.95
```

### Estrat√©gia 2: Maioria Qualificada

```python
buy_votes = sum(1 for s in agent_signals.values() if s['direction'] == 1)
if buy_votes >= 3 and ml_prediction > 0:
    # Maioria dos agentes + ML concordam
    signal = 'BUY'
    size = normal_position_size
    confidence = 0.75
```

### Estrat√©gia 3: Especialista Dominante

```python
if agent_signals['OrderFlowSpecialist']['confidence'] > 0.9:
    # Especialista com alta confian√ßa override outros
    signal = agent_signals['OrderFlowSpecialist']['signal']
    size = normal_position_size * 0.8
    confidence = 0.80
```

## üîß Configura√ß√£o e Tuning

### Par√¢metros por Agente

```json
{
  "OrderFlowSpecialist": {
    "imbalance_threshold": 0.3,
    "momentum_periods": [5, 10, 20],
    "absorption_sensitivity": 0.7,
    "min_confidence": 0.60
  },
  "LiquidityAgent": {
    "liquidity_lookback": 100,
    "spread_threshold": 2.0,
    "depth_levels": 5,
    "min_confidence": 0.55
  },
  "TapeReadingAgent": {
    "large_trade_percentile": 90,
    "velocity_window": 10,
    "pattern_sensitivity": 0.65,
    "min_confidence": 0.60
  },
  "FootprintPatternAgent": {
    "volume_concentration_threshold": 0.7,
    "delta_significance": 100,
    "poc_window": 50,
    "min_confidence": 0.55
  }
}
```

### M√©tricas de Performance

```python
# M√©tricas por agente
agent_metrics = {
    'accuracy': 0.65,        # Taxa de acerto
    'sharpe_ratio': 1.8,     # Risk-adjusted return
    'avg_confidence': 0.72,  # Confian√ßa m√©dia
    'contribution': 0.25,    # Contribui√ß√£o para P&L
    'agreement_rate': 0.6    # Taxa de concord√¢ncia com consenso
}

# M√©tricas do ensemble
ensemble_metrics = {
    'consensus_accuracy': 0.70,
    'diversity_index': 0.4,      # Diversidade de opini√µes
    'stability': 0.85,           # Estabilidade de sinais
    'adaptation_rate': 0.1       # Taxa de adapta√ß√£o de pesos
}
```

## üö® Monitoramento e Alertas

### Dashboard de Agentes

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           HMARL AGENTS MONITOR                ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Agent                ‚îÇ Signal ‚îÇ Conf ‚îÇ Weight ‚ïë
‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢
‚ïë OrderFlowSpecialist ‚îÇ  BUY   ‚îÇ 75%  ‚îÇ  30%   ‚ïë
‚ïë LiquidityAgent      ‚îÇ  HOLD  ‚îÇ 60%  ‚îÇ  20%   ‚ïë
‚ïë TapeReadingAgent    ‚îÇ  BUY   ‚îÇ 82%  ‚îÇ  25%   ‚ïë
‚ïë FootprintPattern    ‚îÇ  BUY   ‚îÇ 68%  ‚îÇ  25%   ‚ïë
‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢
‚ïë ML Model            ‚îÇ  BUY   ‚îÇ 71%  ‚îÇ  40%   ‚ïë
‚ïë CONSENSUS           ‚îÇ  BUY   ‚îÇ 73%  ‚îÇ  ---   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

### Alertas Cr√≠ticos

1. **Diverg√™ncia Extrema**: Agentes em total desacordo
2. **Confian√ßa Baixa**: Todos os agentes < 50% confian√ßa
3. **Mudan√ßa de Regime**: Padr√µes anormais detectados
4. **Falha de Agente**: Agente n√£o respondendo

## üìä Backtesting de Agentes

```python
def backtest_agent(agent, historical_data):
    """Testa performance hist√≥rica de um agente"""
    
    signals = []
    for timestamp, features in historical_data:
        signal = agent.analyze(features)
        signals.append({
            'time': timestamp,
            'signal': signal,
            'actual': historical_data.get_outcome(timestamp)
        })
    
    # Calcular m√©tricas
    accuracy = calculate_accuracy(signals)
    sharpe = calculate_sharpe(signals)
    drawdown = calculate_max_drawdown(signals)
    
    return {
        'accuracy': accuracy,
        'sharpe': sharpe,
        'max_drawdown': drawdown,
        'total_signals': len(signals)
    }
```

## üéØ Best Practices

### 1. Diversidade de Agentes
- Cada agente deve ter foco diferente
- Evitar correla√ß√£o alta entre agentes
- Manter independ√™ncia de decis√£o

### 2. Gest√£o de Confian√ßa
- Nunca for√ßar trade com baixa confian√ßa
- Usar confian√ßa para sizing de posi√ß√£o
- Monitorar degrada√ß√£o de confian√ßa

### 3. Adapta√ß√£o Cont√≠nua
- Atualizar pesos semanalmente
- Retreinar agentes mensalmente
- Avaliar novos padr√µes trimestralmente

### 4. Risk Management
- Cada agente tem stop loss pr√≥prio
- Consenso inclui avalia√ß√£o de risco
- Circuit breakers por agente

## üî¨ Pesquisa e Desenvolvimento

### Melhorias Futuras

1. **Deep Learning Agents**: LSTM para sequ√™ncias
2. **Meta-Learning**: Agente que aprende a ponderar outros
3. **Adversarial Training**: Agente advers√°rio para robustez
4. **Transfer Learning**: Compartilhar conhecimento entre mercados

### Papers de Refer√™ncia

- "Multi-Agent Reinforcement Learning in Trading" (2023)
- "Hierarchical Decision Making in Financial Markets" (2022)
- "Ensemble Methods for High-Frequency Trading" (2023)

---

**O sistema HMARL representa o estado da arte em trading algor√≠tmico, combinando especializa√ß√£o, adapta√ß√£o e robustez.**